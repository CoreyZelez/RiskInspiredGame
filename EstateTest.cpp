#include "EstateTest.h"
#include "Barony.h"
#include "Territory.h"
#include "LandArmy.h"
#include "Player.h"

void EstateTest::test()
{
	test1();
	test2();
}

void EstateTest::test1()
{
	std::string testName = "barony yielding land army";
	
	Player player;
	LandTerritory territory(0);
	const double landArmyYield = 0.4;
	std::unique_ptr<Estate> barony = std::make_unique<Barony>(territory, landArmyYield);
	barony.get()->initRuler(player);
	
	// Attempt to yield land army with cumulative land army not surpassing threshold.
	player.handleFiefYields();
	if(territory.getArmy().get() != nullptr)
	{
		bool result = false;
		std::string message = "unexpected land army yielded";
		testReport(testName, result, message);
		return;
	}
	
	// Attempts to successfully yield a land army.
	// 20 loops executed as this should guaruntee surpassing threshold for any sanely chosen threshold value.
	for(int i = 0; i < 20; ++i)  
	{
		player.handleFiefYields();
	}
	if(territory.getArmy().get() == nullptr)
	{
		bool result = false;
		std::string message = "no land army yielded to territory";
		testReport(testName, result, message);
		return;
	}
	else if(&territory.getArmy().get()->getOwner() != &player)
	{
		bool result = false;
		std::string message = "incorrect owner of yielded land army";
		testReport(testName, result, message);
		return;
	}
	
	// Test succeeded.
	bool result = true;
	testReport(testName, result);
}

void EstateTest::test2()
{
	std::string testName = "county providing bonus yields";

	Player player1;
	Player player2;
	Player player3;
	LandTerritory territory1(0);
	LandTerritory territory2(1);
	LandTerritory territory3(2);
	LandTerritory territory4(3);

	const double landArmyYield = 0.4;
	std::unique_ptr<Estate> barony1 = std::make_unique<Barony>(territory1, landArmyYield);
	std::unique_ptr<Estate> barony2 = std::make_unique<Barony>(territory2, landArmyYield);
	std::unique_ptr<Estate> barony3 = std::make_unique<Barony>(territory3, landArmyYield);
	std::unique_ptr<Estate> barony4 = std::make_unique<Barony>(territory4, landArmyYield); 
	std::unique_ptr<Estate> county = std::make_unique<Estate>(Title::count);

	county.get()->addSubfief(barony1.get());
	county.get()->addSubfief(barony2.get());
	county.get()->addSubfief(barony3.get());
	county.get()->addSubfief(barony4.get());  

	barony1.get()->initRuler(player1);
	barony2.get()->initRuler(player1);
	barony3.get()->initRuler(player2);
	county.get()->initRuler(player2);
	barony4.get()->initRuler(player3);  // player3 will not be apart of player2's realm.

	player2.getRelationshipManager().addVassal(player1);

	player2.handleFiefYields();
	player1.handleFiefYields();
	if(territory1.getArmy().get() != nullptr)
	{
		bool result = false;
		std::string message = "unexpected land army yielded";
		testReport(testName, result, message);
		return;
	}

	// Attempts to successfully yield a land army through yields only generated by bonus yields provided by county to baronies.
    // 150 loops executed as this should guaruntee surpassing yield threshold for any sanely chosen threshold value.
	for(int i = 0; i < 150; ++i)
	{
		player2.handleFiefYields();
	}
	player1.handleFiefYields();
	if(territory1.getArmy().get() == nullptr)
	{
		bool result = false;
		std::string message = "no land army yielded to territory";
		testReport(testName, result, message);
		return;
	}
	else if(&territory1.getArmy().get()->getOwner() != &player1)
	{
		bool result = false;
		std::string message = "incorrect owner of yielded land army";
		testReport(testName, result, message);
		return;
	}

	// Checks that the player not apart of the realm was not receiving the bonus yields.
	player3.handleFiefYields();
	if(territory4.getArmy().get() != nullptr)
	{
		bool result = false;
		std::string message = "player receiving bonus yields from a player in a different realm";
		testReport(testName, result, message);
		return;
	}

	bool result = true;
	testReport(testName, result);
}
